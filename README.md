# Итоги

## Движок

- Предпологается что каждая программа это ``Решение``. Решение вмещает в себя готовую совокупность файлов который позволят скоплировать данную программу в ``exe`` файл.

- Весь исходный код компилируеся с помощью ``CLR`` в ``IL - код`` и превращается в ``Managed Module (управляемый код)``.

- Имеется двухфазная компиляция.

1. Компиляция исходного кода ``C#`` в ``IL`` - код.
2. Компиляция ``IL - кода`` в машинный посредством ``JIT compiler``.

### CLR

Общеязыковая среда выполнения ``(Common Language Runtime, CLR)``
Среда выполнения, которая подходит для разных языков программирования.

CLR может:

1. Управляет памятью.
2. Загрузка сборок.
3. Безопасность.
4. Обработка исключений.
5. Синхронизация.

Компилятор языка поддерживает ``CLR``.

Компилятор проверяет правильность написания кода, а затем компилирует код в ``Управляемый модуль (managed module)``.

Части управляемого модуля:

1. Заголовок PE или PE32+, указывает тип файла: ``GUI``, ``CUI``, ``DDL``, а так же метка времени создания.
2. Заголовок CLR, версия, флаги, метаданные ``MethodDef(Main) точка входа``, размер/месторасположение метаданных модуля, строгого имени, файлов.
3. Метаданные, типы данных и их члены.
4. IL - код (Intermediate Language).

Managed Module - это стандартный переносимый исполняемый файл ``(portable executable) PE`` который может быть 32-разрядный ``(PE32)`` или 64-разрядный Windows ``(PE32+)`` и он требует для выполнения среды ``CLR``.

Управляемая сборка использует функции безопасности ``Предотвращения выполнения данных (DEP, Data Execution Prevention)`` и  технологию ``(ASLR, Addres Space Layout Optimization)``.

CLR - совместимые компиляторы генерируют ``IL - код (Itermediate Language)``.

IL - код, итогда называют ``управляемым (managed code)``, потому что CLR управляет его выполнением.

Преймущества:

1. CLR помогает разработчику абстрагировать от конкретного процессора.

2. CLR проводит верификацию кода (проверку на ошибки и опасности, так же защита других процессов от вмешательства приложения в другие адрессные пространства).

3. CLR позволяет запустить несколько приложений в рамках одного процесса.

### Метаданные

Компилятор компилирует ``metadata`` для каждого управляемого модуля.

Метаданные - это набор таблиц данных, описывающих то, что определенно в модуле, например типи и их члены.

Метаданные CLR содержат полную информацию и они всегда связанны с файлом содержащий ``IL - код``.

Фактически метаданные всегда встроены в тот же ``EXE или DDL`` файл что и код, их нельзя разделить - рассинхронизация метаданных и описываемого ими IL - кода исключена.

## Парадигма

- Объектно ориентированное программирование (ООП) и только оно.

- Функциональное программирование - исключенно.

## Типизация

- Строгая типизация.

- Необоходимо указывать тип данных для каждого элемента.

- Если тип данных не совпадает, компиляция не может быть выполенна.

## Синтаксис

- Есть синтаксические различия.

## Переменные

- Есть различия работы с переменными.
    1. Ссылку можно создать без значения ``int var;``.
    2. Присвоить ссылке значение можно позже ``var = 30;``.
    3. Работа с аргументами в функция совпадает с python.

## Типы

- Есть отличия в автоматической конвертации типов.

- При автоматической конвертации приводится к стандартному типу даннных по объему занимаемых byte.

- Много различных типов данных: ``string``, ``char``, ``byte``, ``sbyte`` (singned byte), ``ushort (unsinged)``, ``short``, ``uint (unsinged)``, ``int``, ``ulong (unsinged)``, ``long``, ``float``, ``double``, ``decimal``.

- singned говорит о том что данная величина может быть отрицательной, по умолчанию все singned кроме byte (Делит пополам выделенные bytes и выделяет каждую часть под новый период (64 bytes / 2: 32 bytes на минусовые значение и 32 bytes на положительные)).

- Для принудительной конвертации типа необоходимо прописать в скобках желаемый тип:

```C#
int numb = 20;
string str = (string) numb;
```

- Есть литеральные значения которые помечаются одинарными ковычками ``'A'``, ``69``.

- Строки помечаются только двойными ковычками ``"string"``.

- Под капотом все состоит из литераллов, даже тип ``string`` состоит из отдельных литераллов который в сумме даeт строку.

- Если конвертировать буквенный литералл в цифру - получим код литералла и наоборот (``ord()`` в python делает тоже самое).

- Есть тип данных ``Массив``.
    1. Массив бывает одноменым, двухмерным, много мерным.
    2. С помощью Rank можно узнать мерность массива.
    3. С помощью GetLength можно узнать длину мерности.

- Для создания ``Массива`` нужно вызвать конструктор (``new``) нужного типа данных с обозначением массива:

```C#
int[] array = new int[10];
```

- В ``[]`` указывается длина массива.

## Методы

### Параметры

- Мы можем возвращать несколько значение из метода с помощью ``out``:

```C#
static int GetMin(int[] nums, out int index) {
    index = 0;
    for (int k = 1; k < nums.Length; k++) {
        if (nums[k] < nums[index]) {
            index = k;
        }
    }
    return nums[index];
}

int[] nums = {1, 3, 4, 5};
int index;
int min = GetMin(nums, out index);
```

Таким образом мы обрабатываем внешнюю переменную которую мы за ранее объявили и метод обработает ее и изменит значениие.

- Мы можем указывать механизм ``params`` по аналогии *args в Python.

```C#
static string GetText(string t, params int[] a) {
    string res = "";
    for (int k = 0; k < a.Length; k++) {
        res += t[a[k]];
    }
    return res;
}
```

### Документация

- Вся документация производится в ``XML`` формате и ``///``

```C#

/// <summary>
/// Выбирает <c>слово</c> из списка индексов в параметрах.
/// (<paramref name="a"/>,<paramref name="t"/>).
/// </summary>
/// <param name="t">Строка для поиска</param>
/// <param name="a">Индексы для составления нового слова</param>
/// <returns>
/// Новое слово исходя из индексов
/// </returns>
static string GetText(string t, params int[] a) {
    // Тело метода
}
```
